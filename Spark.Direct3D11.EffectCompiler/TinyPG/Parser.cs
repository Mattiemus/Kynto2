// Generated by TinyPG v1.3 available at www.codeproject.com

namespace Spark.Direct3D11.Graphics
{
    #region Parser

    internal partial class Parser
    {
        private Scanner scanner;
        private ParseTree tree;

        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);



            tok = scanner.LookAhead(TokenType.Code, TokenType.Technique);
            while (tok.Type == TokenType.Code
                || tok.Type == TokenType.Technique)
            {
                tok = scanner.LookAhead(TokenType.Code, TokenType.Technique);
                switch (tok.Type)
                {
                    case TokenType.Code:
                        tok = scanner.Scan(TokenType.Code);
                        n = node.CreateNode(tok, tok.ToString());
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.Code)
                        {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Code.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                            return;
                        }
                        break;
                    case TokenType.Technique:
                        ParseTechnique_Declaration(node);
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
                tok = scanner.LookAhead(TokenType.Code, TokenType.Technique);
            }


            tok = scanner.Scan(TokenType.EndOfFile);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EndOfFile)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EndOfFile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTechnique_Declaration(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Technique_Declaration), "Technique_Declaration");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.Technique);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Technique)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Technique.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.Identifier);
            if (tok.Type == TokenType.Identifier)
            {
                tok = scanner.Scan(TokenType.Identifier);
                n = node.CreateNode(tok, tok.ToString());
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Identifier)
                {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }


            tok = scanner.Scan(TokenType.OpenBracket);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenBracket)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenBracket.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            do
            {
                ParsePass_Declaration(node);
                tok = scanner.LookAhead(TokenType.Pass);
            } while (tok.Type == TokenType.Pass);


            tok = scanner.Scan(TokenType.CloseBracket);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseBracket)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseBracket.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePass_Declaration(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Pass_Declaration), "Pass_Declaration");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.Pass);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Pass)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Pass.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.Identifier);
            if (tok.Type == TokenType.Identifier)
            {
                tok = scanner.Scan(TokenType.Identifier);
                n = node.CreateNode(tok, tok.ToString());
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Identifier)
                {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }


            tok = scanner.Scan(TokenType.OpenBracket);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenBracket)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenBracket.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.SetVertexShader, TokenType.SetPixelShader, TokenType.SetGeometryShader, TokenType.SetDomainShader, TokenType.SetHullShader, TokenType.SetComputeShader);
            while (tok.Type == TokenType.SetVertexShader
                || tok.Type == TokenType.SetPixelShader
                || tok.Type == TokenType.SetGeometryShader
                || tok.Type == TokenType.SetDomainShader
                || tok.Type == TokenType.SetHullShader
                || tok.Type == TokenType.SetComputeShader)
            {
                tok = scanner.LookAhead(TokenType.SetVertexShader, TokenType.SetPixelShader, TokenType.SetGeometryShader, TokenType.SetDomainShader, TokenType.SetHullShader, TokenType.SetComputeShader);
                switch (tok.Type)
                {
                    case TokenType.SetVertexShader:
                        tok = scanner.LookAhead(TokenType.SetVertexShader);
                        if (tok.Type == TokenType.SetVertexShader)
                        {
                            ParseSetVertexShader_Expression(node);
                        }
                        break;
                    case TokenType.SetPixelShader:
                        tok = scanner.LookAhead(TokenType.SetPixelShader);
                        if (tok.Type == TokenType.SetPixelShader)
                        {
                            ParseSetPixelShader_Expression(node);
                        }
                        break;
                    case TokenType.SetGeometryShader:
                        tok = scanner.LookAhead(TokenType.SetGeometryShader);
                        if (tok.Type == TokenType.SetGeometryShader)
                        {
                            ParseSetGeometryShader_Expression(node);
                        }
                        break;
                    case TokenType.SetDomainShader:
                        tok = scanner.LookAhead(TokenType.SetDomainShader);
                        if (tok.Type == TokenType.SetDomainShader)
                        {
                            ParseSetDomainShader_Expression(node);
                        }
                        break;
                    case TokenType.SetHullShader:
                        tok = scanner.LookAhead(TokenType.SetHullShader);
                        if (tok.Type == TokenType.SetHullShader)
                        {
                            ParseSetHullShader_Expression(node);
                        }
                        break;
                    case TokenType.SetComputeShader:
                        tok = scanner.LookAhead(TokenType.SetComputeShader);
                        if (tok.Type == TokenType.SetComputeShader)
                        {
                            ParseSetComputeShader_Expression(node);
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
                tok = scanner.LookAhead(TokenType.SetVertexShader, TokenType.SetPixelShader, TokenType.SetGeometryShader, TokenType.SetDomainShader, TokenType.SetHullShader, TokenType.SetComputeShader);
            }


            tok = scanner.Scan(TokenType.CloseBracket);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseBracket)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseBracket.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetVertexShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetVertexShader_Expression), "SetVertexShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetVertexShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetVertexShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetVertexShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.VSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.VSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetPixelShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetPixelShader_Expression), "SetPixelShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetPixelShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetPixelShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetPixelShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.PSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetGeometryShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetGeometryShader_Expression), "SetGeometryShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetGeometryShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetGeometryShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetGeometryShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.GSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.GSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetDomainShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetDomainShader_Expression), "SetDomainShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetDomainShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetDomainShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetDomainShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.DSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetHullShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetHullShader_Expression), "SetHullShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetHullShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetHullShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetHullShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.HSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.HSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSetComputeShader_Expression(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetComputeShader_Expression), "SetComputeShader_Expression");
            parent.Nodes.Add(node);



            tok = scanner.Scan(TokenType.SetComputeShader);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SetComputeShader)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SetComputeShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.OpenParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.LookAhead(TokenType.CompileShader, TokenType.NULL);
            switch (tok.Type)
            {
                case TokenType.CompileShader:


                    tok = scanner.Scan(TokenType.CompileShader);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CompileShader)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CompileShader.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CSShaderProfile);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CSShaderProfile)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CSShaderProfile.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Comma);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.Identifier);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Identifier)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.OpenParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }


                    tok = scanner.Scan(TokenType.CloseParentheses);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParentheses)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.NULL:
                    tok = scanner.Scan(TokenType.NULL);
                    n = node.CreateNode(tok, tok.ToString());
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NULL)
                    {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }


            tok = scanner.Scan(TokenType.CloseParentheses);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParentheses)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParentheses.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }


            tok = scanner.Scan(TokenType.Semicolon);
            n = node.CreateNode(tok, tok.ToString());
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon)
            {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
